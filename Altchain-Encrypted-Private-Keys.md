There is no limit to the potential deviation of an *altcoin* from Bitcoin standards, so its not possible for us to support all altcoins generally. We do strive to support *altchains*. In other words, to the extent that an alt uses Bitcoin standards, but with distinct consensus rules, we intend to support it.

It is our goal to support altchains without a rebuild of any library, so any compiled libbitcoin binary supports them all. This cannot be generally extended to consensus deviations so it is our intent to implement pluggable consensus modules. We currently support testnet but this will not be entirely free of conditional compilation until the version3 release.

These considerations drive the outcome on this question. There are three [base58check](https://en.bitcoin.it/wiki/Base58Check_encoding) (serializable) primitives associated with [BIP-38](https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki), which libbitcoin refers to as follows:

* `private_key` : encrypted private key 
* `public_key` : encrypted public key
* `token` : intermediate passphrase string

In accordance with BIP-38 these have the following prefix values:
```cpp
namespace prefix
{
    // This prefix results in the prefix "6P" in the base58 encoding.
    static const data_chunk private_key
    {
        0x01, 0x42
    };

    // This prefix results in the prefix "6P" in the base58 encoding.
    static const data_chunk private_key_multiplied
    {
        0x01, 0x43
    };

    // This prefix results in the prefix "cfrm" in the base58 encoding.
    static const data_chunk public_key
    {
        0x64, 0x3b, 0xf6, 0xa8, 0x9a
    };

    // This prefix results in the prefix "passphrase" in the base58 encoding.
    static const data_chunk lot_token
    {
        0x2c, 0xe9, 0xb3, 0xe1, 0xff, 0x39, 0xe2, 0x51
    };

    // This prefix results in the prefix "passphrase" in the base58 encoding.
    static const data_chunk plain_token
    {
        0x2c, 0xe9, 0xb3, 0xe1, 0xff, 0x39, 0xe2, 0x53
    };
}
```
The first byte of each of these is the [base58check version](https://github.com/libbitcoin/libbitcoin-explorer/wiki/bx-base58check-encode#example-2). This of course should not be confused with a payment address base58check version. BIP-38 serializes payment addresses before hashing. So there is also a payment address version affecting each of the three primitives. Notably the [compression option for ec public keys](https://github.com/libbitcoin/libbitcoin-explorer/wiki/bx-ec-to-address#example-1) also affects these artifacts.

BIP-38 carries the compression flag through the encoding. As a consequence there is no need to have knowledge of the compression value used in creation of the keys in order to decrypt the keys. This is not the case with the payment address version. Three options exist that are consistent with BIP-38:

1. The payment address version is always Bitcoin mainnet `0x01` (with compression specified at encryption time).
2. The payment address version and compression are specified at encryption time, and the correct payment address version *must also* be provided at decryption time. This apples to decryption of both the private key and the public key if one desires to reconstitute a payment address - as envisioned by BIP-38.
3. The payment address version and compression are specified only at encryption time.

The first doesn’t even support testnet. The second is poor from a user scenario perspective. The third provides support for altchains that is consistent with BIP-38 behavior for Bitcoin mainnet. There are two ways to implement this option:

 1. Hard code a partial mapping between [well-known payment address versions](https://en.bitcoin.it/wiki/List_of_address_prefixes) and corresponding encrypted key versions, and deploy universal code changes as this mapping evolves to fill the 256 bit domain.
 2. Define a deterministic bidirectional mapping between the payment address and the encrypted key addresses.

### BIP-38 Suggestions Regarding Altchains
> Alt-chain implementers should exploit the address hash for this purpose. Since each operation in this proposal involves hashing a text representation of a coin address which (for Bitcoin) includes the leading '1', an alt-chain can easily be denoted simply by using the alt-chain's preferred format for representing an address. Alt-chain implementers may also change the prefix such that encrypted addresses do not start with "6P". [[hyperlink](https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki#suggestions-for-implementers-of-proposal-with-alt-chains)]

The above appears to assume that altchains will hard code the payment address version into applications. Otherwise the scenario is degraded for altchain usage, as described previously. Given that it is a requirement for libbitcoin to avoid compilation for specific altchains, this assumption does not hold.

### Proposal
Given that encrypted keys already have a dependency on payment address versions there appears to be no reason to support a non-deterministic version mapping. A deterministic mapping is straightforward to implement and is immune to evoluation of the published address version and encrypted key prefix domains.

### Backward Compatibility
The payment address version can simply be coupled to the base58check version byte for a corresponding encrypted private key. There is however one idiosyncrasy required for backward compatibility.

For the base58check version byte BIP-38 uses `0x01` for `private_key` and `0x64` for `public_key`. These correspond to the Bitcoin mainnet payment address version of `0x00`. As such the following bidirectional mapping is proposed.

```cpp
uint8_t address_to_prefix(const uint8_t address_version, const data_chunk& default_prefix)
{
    const auto default_prefix_version = default_prefix[0];
    return address_version == payment_address::pubkey_version ?
        default_prefix_version : address_version;
}

uint8_t prefix_to_address(const uint8_t prefix_version, const data_chunk& default_prefix)
{
    const auto default_prefix_version = default_prefix[0];
    return prefix_version == default_prefix_version ?
        payment_address::pubkey_version : prefix_version;
}
```

### Cosmetic Inflexibility
A possible problem would be inflexibility in the cosmetics of the first couple of characters in encrypted keys. Some choice would remain with a deterministic mapping, but it would be coupled to the choice of payment address version and would be limited to one byte. In other words each could not be independently chosen for the same altchain.

### Limited Payment Address Version Domain
It is also true that there is a finite domain of 256 values for the payment address version. However this issue cannot be resolved by expanding the domain of encrypted private keys that are coupled to that domain. It seems preferable to attach any expansion to the encrypted key domain to a corresponding expansion of the payment address domain.

### Effect on Serialized Artifacts
The implementation as described has no impact on intermediate passphrase `token` serialization. This artifact retains its encoded prefix of "passphrase" and as such this value will be chain ambiguous.

BIP-38 declares the natural language abbreviation (confirm) prefix `cfrm` for the `public_key` and `6P` for the `private_key`, where the `P` represents password protection and `6` is intended to deconflict with typical WIF keys. Deterministic derivation from the payment address version abandons a natural language prefix for both the `private_key` and `public_key` prefixes.

Because of leading zeros the base58 encodings vary slightly in length.

### BIP38 Intermediate Code Limitations
In BIP38 terminology, an [intermediate code](https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki#encryption-when-ec-multiply-mode-is-used) is a token generated by an `owner` and supplied to a `printer`. The token can incorporate arbitrary `lot` and `sequence` values for required incorporation into printer-generated keys.

However the token cannot carry the owner's required address constraints, specifically version but also compression. This limits the utility of the token. A printer can generate keys for addresses that pass validation via the owner's passphrase but are nonetheless not usable by the owner due to use compression. The printer is in control of the public key compression state in generated encrypted keys.

Similarly, in the proposed version mapping it is not possible for the owner to constrain the address version. As with key compression, it can only be validated by obtaining the value and explicitly comparing it to what is desired. This could be resolved by modifying the proposal to hash compression and version information into the intermediate code.

### Full Map Cosmetics
```
0x00 -> 6P... cfrm...
0x01 -> 6P... SUYP...
0x02 -> Af... o7g8...
0x03 -> Ew... 29ko...
0x04 -> KD... 2WPw...
0x05 -> PV... 2s35...
0x06 -> Tk... 3DgD...
0x07 -> Y2... 3aKL...
0x08 -> cJ... 3vxU...
0x09 -> ga... 4Hbc...
0x0a -> kr... 4eEk...
0x0b -> q7... 4zss...
0x0c -> uP... 5MX1...
0x0d -> yf... 5iA9...
0x0e -> 23... 64oH...
0x0f -> 28... 6RSQ...
0x10 -> 2C... 6n5Y...
0x11 -> 2G... 78ig...
0x12 -> 2M... 7VMp...
0x13 -> 2R... 7qzw...
0x14 -> 2V... 8Ce5...
0x15 -> 2Z... 8ZHD...
0x16 -> 2e... 8uvM...
0x17 -> 2i... 9GZU...
0x18 -> 2n... 9dCc...
0x19 -> 2r... 9yqk...
0x1a -> 2w... ALUs...
0x1b -> 31... Ah81...
0x1c -> 35... B3m9...
0x1d -> 3A... BQQH...
0x1e -> 3E... Bm3Q...
0x1f -> 3J... C7gY...
0x20 -> 3N... CUKg...
0x21 -> 3T... Cpxp...
0x22 -> 3X... DBbw...
0x23 -> 3b... DYF5...
0x24 -> 3f... DttD...
0x25 -> 3k... EFXM...
0x26 -> 3p... EcAU...
0x27 -> 3t... Exoc...
0x28 -> 3y... FKSk...
0x29 -> 43... Fg5t...
0x2a -> 47... G2j1...
0x2b -> 4B... GPN9...
0x2c -> 4G... Gk1H...
0x2d -> 4L... H6eR...
0x2e -> 4Q... HTHY...
0x2f -> 4U... Hovg...
0x30 -> 4Z... JAZp...
0x31 -> 4d... JXCx...
0x32 -> 4h... Jsr5...
0x33 -> 4n... KEVD...
0x34 -> 4r... Kb8M...
0x35 -> 4v... KwmV...
0x36 -> 4z... LJQc...
0x37 -> 55... Lf3k...
0x38 -> 59... M1gt...
0x39 -> 5D... MNL2...
0x3a -> 5H... Miy9...
0x3b -> 5N... N5cH...
0x3c -> 5S... NSFR...
0x3d -> 5W... NntZ...
0x3e -> 5b... P9Xg...
0x3f -> 5f... PWAp...
0x40 -> 5j... Prox...
0x41 -> 5o... QDT5...
0x42 -> 5t... Qa6D...
0x43 -> 5x... QvjM...
0x44 -> 62... RHNV...
0x45 -> 66... Re1c...
0x46 -> 6B... Rzek...
0x47 -> 6F... SMHt...
0x48 -> 6K... Shw2...
0x49 -> 6Q... T4a9...
0x4a -> 6U... TRDH...
0x4b -> 6Y... TmrR...
0x4c -> 6c... U8VZ...
0x4d -> 6h... UV8g...
0x4e -> 6m... Uqmp...
0x4f -> 6q... VCQx...
0x50 -> 6u... VZ46...
0x51 -> 6z... VuhD...
0x52 -> 74... WGLM...
0x53 -> 78... WcyV...
0x54 -> 7D... Wycd...
0x55 -> 7H... XLFk...
0x56 -> 7M... Xgtt...
0x57 -> 7R... Y3Y2...
0x58 -> 7W... YQBA...
0x59 -> 7a... YkpH...
0x5a -> 7e... Z7TR...
0x5b -> 7i... ZU6Z...
0x5c -> 7o... Zpjh...
0x5d -> 7s... aBNp...
0x5e -> 7w... aY1x...
0x5f -> 82... atf6...
0x60 -> 86... bFJE...
0x61 -> 8A... bbwM...
0x62 -> 8E... bxaV...
0x63 -> 8K... cKDd...
0x64 -> 8P... cfrm...
0x65 -> 8T... d2Vt...
0x66 -> 8X... dP92...
0x67 -> 8c... djnA...
0x68 -> 8g... e6RJ...
0x69 -> 8k... eT4R...
0x6a -> 8q... eohZ...
0x6b -> 8u... fALh...
0x6c -> 8y... fWyp...
0x6d -> 93... fscx...
0x6e -> 98... gEG6...
0x6f -> 9C... gauE...
0x70 -> 9G... gwYM...
0x71 -> 9L... hJBV...
0x72 -> 9R... hepd...
0x73 -> 9V... i1Tm...
0x74 -> 9Z... iN6t...
0x75 -> 9e... iik2...
0x76 -> 9i... j5PA...
0x77 -> 9n... jS2J...
0x78 -> 9r... jnfR...
0x79 -> 9w... k9JZ...
0x7a -> A1... kVwh...
0x7b -> A5... kraq...
0x7c -> A9... mDDx...
0x7d -> AE... mZs6...
0x7e -> AJ... mvWE...
0x7f -> AN... nH9N...
0x80 -> AT... ndnV...
0x81 -> AX... nzRd...
0x82 -> Ab... oM4m...
0x83 -> Af... ohhu...
0x84 -> Ak... p4M2...
0x85 -> Ap... pQzA...
0x86 -> At... pmdJ...
0x87 -> Ax... q8GS...
0x88 -> B3... qUuZ...
0x89 -> B7... qqYh...
0x8a -> BB... rCBq...
0x8b -> BF... rYpy...
0x8c -> BL... ruU6...
0x8d -> BQ... sG7E...
0x8e -> BU... sckN...
0x8f -> BZ... syPW...
0x90 -> Bd... tL2d...
0x91 -> Bh... tgfm...
0x92 -> Bm... u3Ju...
0x93 -> Br... uPx3...
0x94 -> Bv... ukbA...
0x95 -> Bz... v7EJ...
0x96 -> C4... vTsS...
0x97 -> C9... vpWZ...
0x98 -> CD... wB9h...
0x99 -> CH... wXnq...
0x9a -> CN... wtRy...
0x9b -> CS... xF56...
0x9c -> CW... xbiE...
0x9d -> Ca... xxMN...
0x9e -> Cf... yJzW...
0x9f -> Cj... yfdd...
0xa0 -> Co... z2Gm...
0xa1 -> Cs... zNuu...
0xa2 -> Cx... zjZ3...
0xa3 -> D2... 216C...
0xa4 -> D6... 21Sq...
0xa5 -> DB... 21oU...
0xa6 -> DF... 22A7...
0xa7 -> DK... 22Wk...
0xa8 -> DP... 22sP...
0xa9 -> DU... 23E2...
0xaa -> DY... 23ag...
0xab -> Dc... 23wK...
0xac -> Dg... 24Hx...
0xad -> Dm... 24eb...
0xae -> Dq... 251E...
0xaf -> Du... 25Ms...
0xb0 -> Dz... 25iW...
0xb1 -> E4... 265A...
0xb2 -> E8... 26Ro...
0xb3 -> EC... 26nS...
0xb4 -> EH... 2795...
0xb5 -> EM... 27Vi...
0xb6 -> ER... 27rM...
0xb7 -> EV... 28Cz...
0xb8 -> Ea... 28Zd...
0xb9 -> Ee... 28vH...
0xba -> Ei... 29Gv...
0xbb -> Eo... 29dZ...
0xbc -> Es... 29zC...
0xbd -> Ew... 2ALq...
0xbe -> F1... 2AhU...
0xbf -> F6... 2B47...
0xc0 -> FA... 2BQm...
0xc1 -> FE... 2BmQ...
0xc2 -> FJ... 2C83...
0xc3 -> FP... 2CUg...
0xc4 -> FT... 2CqK...
0xc5 -> FX... 2DBx...
0xc6 -> Fc... 2DYb...
0xc7 -> Fg... 2DuE...
0xc8 -> Fk... 2EFt...
0xc9 -> Fp... 2EcX...
0xca -> Fu... 2EyA...
0xcb -> Fy... 2FKo...
0xcc -> G3... 2FgS...
0xcd -> G7... 2G35...
0xce -> GC... 2GPi...
0xcf -> GG... 2GkN...
0xd0 -> GL... 2H71...
0xd1 -> GR... 2HTe...
0xd2 -> GV... 2HpH...
0xd3 -> GZ... 2JAv...
0xd4 -> Gd... 2JXZ...
0xd5 -> Gi... 2JtC...
0xd6 -> Gn... 2KEq...
0xd7 -> Gr... 2KbV...
0xd8 -> Gv... 2Kx8...
0xd9 -> H1... 2LJm...
0xda -> H5... 2LfQ...
0xdb -> H9... 2M23...
0xdc -> HE... 2MNg...
0xdd -> HJ... 2MjK...
0xde -> HN... 2N5y...
0xdf -> HS... 2NSc...
0xe0 -> HX... 2NoF...
0xe1 -> Hb... 2P9t...
0xe2 -> Hf... 2PWX...
0xe3 -> Hj... 2PsA...
0xe4 -> Hp... 2QDo...
0xe5 -> Ht... 2QaS...
0xe6 -> Hx... 2Qw6...
0xe7 -> J3... 2RHj...
0xe8 -> J7... 2ReN...
0xe9 -> JB... 2S11...
0xea -> JF... 2SMe...
0xeb -> JL... 2SiH...
0xec -> JQ... 2T4v...
0xed -> JU... 2TRa...
0xee -> JY... 2TnD...
0xef -> Jd... 2U8r...
0xf0 -> Jh... 2UVV...
0xf1 -> Jm... 2Ur8...
0xf2 -> Jr... 2VCm...
0xf3 -> Jv... 2VZQ...
0xf4 -> Jz... 2Vv3...
0xf5 -> K4... 2WGh...
0xf6 -> K9... 2WdL...
0xf7 -> KD... 2Wyy...
0xf8 -> KH... 2XLc...
0xf9 -> KM... 2XhF...
0xfa -> KS... 2Y3t...
0xfb -> KW... 2YQX...
0xfc -> Ka... 2YmB...
0xfd -> Kf... 2Z7p...
0xfe -> Kj... 2ZUT...
0xff -> Ko... 2Zq6...
```
### See Also
Bitcoin Explorer [key encryption commands](https://github.com/libbitcoin/libbitcoin-explorer/wiki/Key-Encryption-Commands)